// Package workerpool предоставляет простую реализацию пула воркеров (worker pool).
// Этот паттерн используется для ограничения количества одновременно выполняемых
// горутин, что помогает контролировать потребление ресурсов (памяти, CPU)
// при обработке большого количества задач.
package workerpool

import (
	"context"
)

// MaxWorkersCount определяет максимальное количество воркеров в пуле,
// то есть максимальное число задач, которые могут выполняться параллельно.
const MaxWorkersCount = 10

// Worker представляет собой "пропуск" на выполнение задачи.
// Наличие Worker в канале `pool` означает, что есть свободный слот
// для выполнения работы. Сама структура пуста, она используется как семафор.
type Worker struct{}

// Pool - это generic-структура для пула воркеров.
// Она может работать с любым типом данных `Data`, который будет передаваться в обработчик.
type Pool[Data any] struct {
	pool    chan *Worker                              // Канал, который работает как семафор, ограничивая количество воркеров.
	handler func(ctx context.Context, msg Data) error // Функция, которая будет выполнять основную работу.
}

// New создает и возвращает новый экземпляр пула воркеров.
//
// Параметры:
//   - handler: функция, которая будет вызываться для обработки каждой единицы данных.
//
// Возвращает:
//   - *Pool[Data]: указатель на созданный пул.
func New[Data any](handler func(ctx context.Context, msg Data) error) *Pool[Data] {
	return &Pool[Data]{
		pool:    make(chan *Worker, MaxWorkersCount),
		handler: handler,
	}
}

// Create "заполняет" пул воркерами. Этот метод нужно вызвать перед
// началом обработки пачки задач, чтобы в канале появились "пропуски".
func (p *Pool[Data]) Create() {
	for range MaxWorkersCount {
		p.pool <- &Worker{}
	}
}

// Handle передает данные на обработку одному из воркеров.
//
// Этот метод блокируется, если все воркеры в пуле заняты.
// Как только воркер освобождается (из канала `pool` удается прочитать значение),
// он "захватывается", выполняется функция `handler`, и после завершения
// воркер возвращается обратно в пул.
func (p *Pool[Data]) Handle(ctx context.Context, data Data) error {
	// Ожидаем, пока в канале `pool` появится свободный воркер.
	w := <-p.pool

	// `defer` гарантирует, что воркер вернется в пул, даже если `handler` запаникует.
	defer func() { p.pool <- w }()

	// Выполняем основную работу.
	return p.handler(ctx, data)
}

// Wait ожидает, пока все воркеры завершат свою работу и вернутся в пул.
// Этот метод следует вызывать после того, как все задачи были отправлены
// в `Handle`, чтобы дождаться их полного выполнения.
func (p *Pool[Data]) Wait() {
	for range MaxWorkersCount {
		// Блокируемся, читая из канала, пока он не наполнится всеми воркерами.
		<-p.pool
	}
}
